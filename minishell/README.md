## 📌 프로젝트 설명

리눅스 쉘의 기본 기능을 직접 구현하는 프로젝트 
명령어 입력을 받아 파싱하고, 적절하게 실행되도록 만드는 일련의 과정을 시스템 호출을 통해 구현하며,  
**사용자 정의 셸의 전반적인 구조와 동작 원리를 익히는 데 목적**

---

## ✨ 주요 구현 기능

- 명령어 파싱 및 실행
- 파이프(`|`)와 리디렉션(`<`, `>`, `>>`, `<<`)
- 환경 변수 (`$VAR`) 확장
- 빌트인 명령어 실행 (`cd`, `echo`, `pwd`, `env`, `export`, `unset`, `exit`)
- 시그널 처리 (`Ctrl+C`, `Ctrl+D`, `Ctrl+\`)
- 히어독 (heredoc)

---

## 🧠 담당 파트: 파싱 (Parsing)

본 프로젝트에서 주로 **파싱 파트를 맡아 구현**하였습니다.

### ✅ 파싱 구현 세부 내용

- **토크나이저 (Tokenizer)**  
  공백, 인용부호(' ", '), 메타문자 (`|`, `<`, `>`)를 구분하여 토큰 리스트 생성

- **쿼트 처리 (Quote Handling)**  
  - 싱글 쿼트: 내부 내용 리터럴 취급
  - 더블 쿼트: 내부에서 `$` 변수 확장 허용

- **환경 변수 확장 (`$VAR`)**  
  - `$HOME`, `$USER` 등 환경 변수 값으로 확장
  - 쿼트 상태에 따라 동작 변화 적용

- **명령어 분리 및 파이프 연결**  
  - `ls -l | grep .c | wc -l` 형식 명령어를 각 파이프 단위로 분리
  - 각 세그먼트마다 명령어와 인자를 정리하여 실행단에 전달

- **리디렉션 처리**  
  - `<`, `>`, `>>`, `<<` 구문 탐지 및 구조 저장
  - 실행 전에 파일 디스크립터 교체용 정보 구성

- **에러 처리**  
  - 닫히지 않은 쿼트, 잘못된 리디렉션, 구문 오류 등을 감지
  - 토큰화 도중 또는 구문 분석 중 명확한 오류 메시지 출력

---

## 🔧 실행 예시

```bash
$ ./minishell
minishell$ echo "Hello $USER"
Hello username

minishell$ cat < input.txt | grep hello >> output.txt

minishell$ export NAME=42
minishell$ echo $NAME
42
```

---

## 🛠️ 사용 기술

- **언어**: C  
- **시스템 함수**: `fork`, `execve`, `pipe`, `dup2`, `read`, `write`, `wait`, `access`, `open`, `close`, `isatty`, `tcgetattr`, `signal`, `getcwd`  
- **라이브러리**: `readline`, `termios`  

---

## 📚 학습 내용

- 리눅스 쉘의 동작 원리
- 입력 문자열의 구문 분석
- 입력을 파이프라인으로 분리하고 파일 디스크립터로 연결
- 환경 변수의 처리와 확장
- 시그널 핸들링과 프로세스 제어
- 리소스 관리 및 메모리 누수 방지

---

## ✅ 빌트인 명령어

| 명령어   | 설명                                |
|----------|-------------------------------------|
| `echo`   | 문자열 출력                         |
| `cd`     | 디렉토리 이동                       |
| `pwd`    | 현재 경로 출력                      |
| `export` | 환경 변수 추가/수정                |
| `unset`  | 환경 변수 제거                      |
| `env`    | 현재 환경 변수 리스트 출력          |
| `exit`   | 셸 종료                              |

---

## ✅ 평가 포인트

- 쉘처럼 동작하는 명령어 처리
- 여러 명령어와 리디렉션/파이프의 조합 처리
- 환경 변수 처리 및 상태 유지
- 시그널과 EOF 처리
- 메모리 누수 없이 종료 (`valgrind` 등으로 확인)
- 코드 구조화 (파싱 / 실행 / 환경변수 / 에러 등 모듈화)
